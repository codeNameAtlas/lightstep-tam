{"version":3,"sources":["../../src/imp/span_imp.js"],"names":[],"mappings":"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","file":"span_imp.js","sourcesContent":["import * as coerce from './coerce.js';\nimport * as constants from '../constants';\nimport _each from '../_each';\nimport * as opentracing from 'opentracing';\nimport { crouton_thrift } from '../platform_abstraction_layer'; // eslint-disable-line camelcase\n\nexport default class SpanImp extends opentracing.Span {\n\n    // ---------------------------------------------------------------------- //\n    // opentracing.Span SPI\n    // ---------------------------------------------------------------------- //\n\n    _tracer() {\n        return this._tracerImp;\n    }\n\n    _context() {\n        return this._ctx;\n    }\n\n    _setOperationName(name) {\n        this._operationName = `${name}`;\n    }\n\n    _addTags(keyValuePairs) {\n        let self = this;\n        _each(keyValuePairs, (value, key) => {\n            self._tags[key] = value;\n        });\n    }\n\n    _log(keyValuePairs, timestamp) {\n        let self = this;\n        const argumentType = typeof keyValuePairs;\n        if (argumentType !== 'object') {\n            self._tracerImp._error('Span.log() expects an object as its first argument');\n            return;\n        }\n\n        let tsMicros = timestamp ?\n            (timestamp * 1000) :\n            self._tracerImp._platform.nowMicros();\n\n        let fields = [];\n        _each(keyValuePairs, (value, key) => {\n            if (!key || !value) {\n                return;\n            }\n            let keyStr = coerce.toString(key);\n            let valStr = null;\n            if (value instanceof Object) {\n                try {\n                    valStr = JSON.stringify(value, null, '  ');\n                } catch (e) {\n                    valStr = `Could not encode value. Exception: ${e}`;\n                }\n            } else {\n                valStr = coerce.toString(value);\n            }\n            if (keyStr.length > self._tracerImp._options.log_field_key_hard_limit) {\n                self._tracerImp._counters['logs.keys.over_limit']++;\n                keyStr = `${keyStr.substr(0, self._tracerImp._options.log_field_key_hard_limit)}...`;\n            }\n            if (valStr.length > self._tracerImp._options.log_field_value_hard_limit) {\n                self._tracerImp._counters['logs.values.over_limit']++;\n                valStr = `${valStr.substr(0, self._tracerImp._options.log_field_value_hard_limit)}...`;\n            }\n            fields.push(new crouton_thrift.KeyValue({\n                Key   : keyStr,\n                Value : valStr,\n            }));\n        });\n        let record = new crouton_thrift.LogRecord({\n            timestamp_micros : tsMicros,\n            fields           : fields,\n        });\n        self._log_records = self._log_records || [];\n        self._log_records.push(record);\n        self._tracerImp.emit('log_added', record);\n    }\n\n    _finish(finishTime) {\n        return this.end(finishTime);\n    }\n\n    // ---------------------------------------------------------------------- //\n    // Private methods\n    // ---------------------------------------------------------------------- //\n\n    constructor(tracer, name, spanContext) {\n        super();\n\n        console.assert(typeof tracer === 'object', 'Invalid runtime');  // eslint-disable-line no-console\n\n        this._tracerImp = tracer;\n        this._ctx = spanContext;\n        this._ended  = false;\n\n        this._operationName = name;\n        this._tags          = {};\n        this._beginMicros   = tracer._platform.nowMicros();\n        this._endMicros     = 0;\n        this._errorFlag     = false;\n        this._log_records   = null;\n    }\n\n    // ---------------------------------------------------------------------- //\n    // LightStep Extensions\n    // ---------------------------------------------------------------------- //\n\n    getOperationName() {\n        return this._operationName;\n    }\n\n    // Getter only. The GUID is immutable once set internally.\n    guid() {\n        return this._ctx._guid;\n    }\n\n    traceGUID() {\n        return this._ctx._traceGUID;\n    }\n\n    parentGUID() {\n        return this._tags.parent_span_guid;\n    }\n\n    setParentGUID(guid) {\n        this._tags.parent_span_guid = coerce.toString(guid);\n        return this;\n    }\n\n    beginMicros() {\n        return this._beginMicros;\n    }\n\n    setBeginMicros(micros) {\n        this._beginMicros = micros;\n        return this;\n    }\n\n    endMicros() {\n        return this._endMicros;\n    }\n\n    setEndMicros(micros) {\n        this._endMicros = micros;\n        return this;\n    }\n\n    /**\n     * Returns a URL to the trace containing this span.\n     *\n     * Unlike most methods, it *is* safe to call this method after `finish()`.\n     *\n     * @return {string} the absolute URL for the span\n     */\n    generateTraceURL() {\n        let micros;\n        if (this._beginMicros > 0 && this._endMicros > 0) {\n            micros = Math.floor((this._beginMicros + this._endMicros) / 2);\n        } else {\n            micros = this._tracerImp._platform.nowMicros();\n        }\n\n        let urlPrefix = constants.LIGHTSTEP_APP_URL_PREFIX;\n        let accessToken = encodeURIComponent(this._tracerImp.options().access_token);\n        let guid = encodeURIComponent(this.guid());\n        return `${urlPrefix}/${accessToken}/trace?span_guid=${guid}&at_micros=${micros}`;\n    }\n\n    getTags() {\n        return this._tags;\n    }\n\n    /**\n     * Finishes the span.\n     *\n     * @param  {Number} finishTime\n     *         \tOptional Unix timestamp in milliseconds setting an explicit\n     *         \tfinish time for the span.\n     */\n    end(finishTime) {\n        // Ensure a single span is not recorded multiple times\n        if (this._ended) {\n            return;\n        }\n        this._ended = true;\n\n        if (finishTime !== undefined) {\n            this._endMicros = finishTime * 1000;\n        }\n\n        // Do not set endMicros if it has already been set. This accounts for\n        // the case of a span that has had it's times set manually (i.e. allows\n        // for retroactively created spans that might not be possible to create\n        // in real-time).\n        if (this._endMicros === 0) {\n            this._endMicros = this._tracerImp._platform.nowMicros();\n        }\n        this._tracerImp._addSpanRecord(this._toThrift());\n    }\n\n    _toThrift() {\n        let attributes = [];\n        _each(this._tags, (value, key) => {\n            attributes.push(new crouton_thrift.KeyValue({\n                Key   : coerce.toString(key),\n                Value : coerce.toString(value),\n            }));\n        });\n\n        let record = new crouton_thrift.SpanRecord({\n            span_guid       : this.guid(),\n            trace_guid      : this.traceGUID(),\n            runtime_guid    : this._tracerImp.guid(),\n            span_name       : this._operationName,\n            oldest_micros   : this._beginMicros,\n            youngest_micros : this._endMicros,\n            attributes      : attributes,\n            error_flag      : this._errorFlag,\n            log_records     : this._log_records,\n        });\n        return record;\n    }\n\n}\n"]}